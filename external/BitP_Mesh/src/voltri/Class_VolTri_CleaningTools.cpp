// ========================================================================== //
//                         - Class_VolTri -                                   //
//                                                                            //
// Grid manager for unstructured volume meshes.                               //
// ========================================================================== //
// INFO                                                                       //
// ========================================================================== //
// Author   : Alessandro Alaia                                                //
// Version  : v2.0                                                            //
//                                                                            //
// All rights reserved.                                                       //
// ========================================================================== //

// ========================================================================== //
// INCLUDES                                                                   //
// ========================================================================== //
# include "Class_VolTri.hpp"

// ========================================================================== //
// SET PARAMETERS                                                             //
// ========================================================================== //

// -------------------------------------------------------------------------- //
void Class_VolTri::SetTolerance(
    void
) {

// ========================================================================== //
// void Class_VolTri::SetTolerance(                                           //
//     void)                                                                  //
//                                                                            //
// Set tolerance for double precisions check.                                 //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                 m, n;
ivector1D           face_vlist;

// Counters
int                 i, j, k;
int                 S, U, V;

// ========================================================================== //
// SET TOLERANCE                                                              //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    n = infos[e_type[S]].n_faces;
    for (i = 0; i < n; ++i) {
        face_vlist = FaceVertices(S, i);
        m = face_vlist.size();
        for (j = 0; j < m; ++j) {
            k = (j+1) % m;
            U = face_vlist[j];
            V = face_vlist[k];
            toll = min(toll, norm2(Vertex[U] - Vertex[V]));
        } //Next j
    } //next i
} //next S
toll = 1.0e-3*toll;

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::SetTolerance(
    a3vector2D              &X
) {

// ========================================================================== //
// void Class_VolTri::SetTolerance(                                           //
//     a3vector2D              &X)                                            //
//                                                                            //
// Set tolerance for double precisions check using an external vertex list.   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X     : a3vector2D, external vertex list                                 //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                 m, n;
ivector1D           face_vlist;

// Counters
int                 i, j, k;
int                 S, U, V;

// ========================================================================== //
// SET TOLERANCE                                                              //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    n = infos[e_type[S]].n_faces;
    for (i = 0; i < n; ++i) {
        face_vlist = FaceVertices(S, i);
        m = face_vlist.size();
        for (j = 0; j < m; ++j) {
            k = (j+1) % m;
            U = face_vlist[j];
            V = face_vlist[k];
            toll = min(toll, norm2(X[U] - X[V]));
        } //Next j
    } //next i
} //next S
toll = 1.0e-3*toll;

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::BinSortV(
    ivector1D               &bin_index,
    int                      n_bins
) {

// ========================================================================== //
// void Class_VolTri::BinSortV(                                               //
//     ivector1D               &bin_index,                                    //
//     int                      n_bins)                                       //
//                                                                            //
// Sort mesh vertices on regular bins.                                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - bin_index     : ivector1D, bin index associated to each vertex.          //
// - n_bins        : int (optional), number of bins                           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double                  dx, dy, dz;
array<double, 2>        xlim, ylim, zlim;

// Counters
int                     i, j, k;
int                     V;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
bin_index.resize(nVertex, -1);

// ========================================================================== //
// ASSOCIATE EACH VERTEX WITH A BIN                                           //
// ========================================================================== //

// -------------------------------------------------------------------------- //
{
    // Compute bounding box extent
    BoundingBox(xlim, ylim, zlim);

    // Bin's spacing
    dx = max(1.0e-12, xlim[1] - xlim[0])/((double) n_bins);
    dy = max(1.0e-12, ylim[1] - ylim[0])/((double) n_bins);
    dz = max(1.0e-12, zlim[1] - zlim[0])/((double) n_bins);

    // Loop over vertices
    for (V = 0; V < nVertex; ++V) {
        i = (Vertex[V][0] - xlim[0])/dx;
        j = (Vertex[V][1] - ylim[0])/dy;
        k = (Vertex[V][2] - zlim[0])/dz;
        bin_index[V] = n_bins*n_bins*k + n_bins*j + i;
    } //next V
}

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::BinSortV(
    a3vector2D              &X,
    ivector1D               &bin_index,
    int                      n_bins
) {

// ========================================================================== //
// void Class_VolTri::BinSortV(                                               //
//     a3vector2D              &X,                                            //
//     ivector1D               &bin_index,                                    //
//     int                      n_bins)                                       //
//                                                                            //
// Sort mesh vertices on regular bins.                                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X             :  a3vector2D, vertex coordinate list. X[i][0], X[i][1],   //
//                    ... are the x, y, ... coordinates of the i-th vertex.   //
// - bin_index     : ivector1D, bin index associated to each vertex.          //
// - n_bins        : int (optional), number of bins                           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                     nX = X.size();
double                  dx, dy, dz;
array<double, 2>        xlim, ylim, zlim;

// Counters
int                     i, j, k;
int                     V;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
bin_index.resize(nX, -1);

// ========================================================================== //
// ASSOCIATE EACH VERTEX WITH A BIN                                           //
// ========================================================================== //

// -------------------------------------------------------------------------- //
{

    // Compute bounding box extent
    BoundingBox(X, xlim, ylim, zlim);

    // Bin's spacing
    dx = max(1.0e-12, xlim[1] - xlim[0])/((double) n_bins);
    dy = max(1.0e-12, ylim[1] - ylim[0])/((double) n_bins);
    dz = max(1.0e-12, zlim[1] - zlim[0])/((double) n_bins);

    // Loop over vertices
    for (V = 0; V < nVertex; ++V) {
        i = (X[V][0] - xlim[0])/dx;
        j = (X[V][1] - ylim[0])/dy;
        k = (X[V][2] - zlim[0])/dz;
        bin_index[V] = n_bins*n_bins*k + n_bins*j + i;
    } //next V
}

return; }

// ========================================================================== //
// BUILD ADJACENCY                                                            //
// ========================================================================== //

// -------------------------------------------------------------------------- //
void Class_VolTri::BuildAdjacency(
    void
) {

// ========================================================================== //
// void Class_VolTri::BuildAdjacency(                                         //
//     void)                                                                  //
//                                                                            //
// Build simplex-simplex adjacency.                                           //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bool                    check;
int                     m, n, p;
bvector2D               flag;
ivector1D               face_vlist;
ivector2D               V2S;

// Counters
int                     i, j, k, l;
int                     V, S, T;

// ========================================================================== //
// RESHAPE ADJACENCY DATA STRUCTURE                                           //
// ========================================================================== //
ReshapeAdjacency();

// ========================================================================== //
// BUILD FLAG                                                                 //
// ========================================================================== //
flag.resize(nSimplex);
for (S = 0; S < nSimplex; ++S) {
    m = infos[e_type[S]].n_faces;
    flag[S].resize(m, true);
} //next S

// ========================================================================== //
// BUILD VERTEX->SIMPLEX CONNECTIVITY                                         //
// ========================================================================== //
V2S.resize(nVertex);
for (S = 0; S < nSimplex; ++S) {
    m = infos[e_type[S]].n_vert;
    for (i = 0; i < m; ++i) {
        V = Simplex[S][i];
        V2S[V].push_back(S);
    } //next i
} //next S

// ========================================================================== //
// BUILD ADJACENCY                                                            //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    m = infos[e_type[S]].n_faces;
    for (i = 0; i < m; i++) {
        check = false;
        if (flag[S][i]) {
            face_vlist = FaceVertices(S, i);
            V = face_vlist[0];
            n = V2S[V].size();
            j = 0;
            while (!check && (j < n)) {
                T = V2S[V][j];
                if (T != S) {
                    p = infos[e_type[T]].n_faces;
                    l = 0;
                    while (!check && (l < p)) {
                        check = SameFace(S, i, T, l);
                        if (check) {
                            Adjacency[S][i] = T;
                            Adjacency[T][l] = S;
                            flag[S][i] = false;
                            flag[T][l] = false;
                        }
                        l++;
                    } //next l
                }
                j++;
            } //next j
        }
    } //next i
} //next S

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::BuildAdjacency(
    a3vector2D              &X
) {

// ========================================================================== //
// void Class_VolTri::BuildAdjacency(                                         //
//     a3vector2D              &X)                                            //
//                                                                            //
// Build simplex-simplex adjacency using an external vertex list.             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X      : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are   //
//            the x, y, ... coordinates of the i-th vertex.                   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                     m, n, p;
int                     nX = X.size();
bvector2D               flag;
ivector1D               face_vlist;
ivector2D               V2S;

// Counters
int                     i, j, k, l;
int                     V, S, T;

// ========================================================================== //
// RESHAPE ADJACENCY DATA STRUCTURE                                           //
// ========================================================================== //
ReshapeAdjacency();

// ========================================================================== //
// BUILD FLAG                                                                 //
// ========================================================================== //
flag.resize(nSimplex);
for (S = 0; S < nSimplex; ++S) {
    m = infos[e_type[S]].n_faces;
    flag[S].resize(m, false);
} //next S

// ========================================================================== //
// BUILD VERTEX->SIMPLEX CONNECTIVITY                                         //
// ========================================================================== //
V2S.resize(nX);
for (S = 0; S < nSimplex; ++S) {
    m = infos[e_type[S]].n_vert;
    for (i = 0; i < m; ++i) {
        V = Simplex[S][i];
        V2S[V].push_back(S);
    } //next i
} //next S

// ========================================================================== //
// BUILD ADJACENCY                                                            //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    m = infos[e_type[S]].n_faces;
    for (i = 0; i < m; ++i) {
        if (flag[S][i]) {
            face_vlist = FaceVertices(S, i);
            V = face_vlist[0];
            n = V2S[V].size();
            for (j = 0; j < n; ++j) {
                T = V2S[V][j];
                p = infos[e_type[T]].n_faces;
                for (l = 0; l < p; ++l) {
                    if (SameFace(S, i, T, l)) {
                        Adjacency[S][i] = T;
                        Adjacency[T][k] = S;
                        flag[S][i] = false;
                        flag[T][k] = false;
                    }
                } //next l
            } //next j
        }
    } //next i
} //next S

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::BuildFaces(
    ivector2D               &S2F,
    ivector2D               &F2S
) {

// ========================================================================== //
// void Class_SurfTri::BuildFaces(                                            //
//     ivector2D               &S2F,                                          //
//     ivector2D               &F2S)                                          //
//                                                                            //
// Generate face data structure.                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - S2F    : ivector2D, simplex->face connectivity. S2F[i][j] is the global  //
//            index of the j-th face of the i-th simplex                      //
// - F2S    : ivector2D, face->simplex connectivity. F2S[i] stores the        //
//            indices of simplicies sharing the i-th face                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector2D               flag;

// Counters
int                     i, j;
int                     n;
int                     A, T, F;

// ========================================================================== //
// BUILD ADJACENCIES IF NOT ALREADY BUILT                                     //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency();
}

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //

// Simplex-->face connectivity ---------------------------------------------- //
S2F.resize(nSimplex);
flag.resize(nSimplex);
for (T = 0; T < nSimplex; ++T) {
    S2F[T].resize(infos[e_type[T]].n_faces, -1);
    flag[T].resize(infos[e_type[T]].n_faces, -1);
} //next T

// Face-->simplex connectivity ---------------------------------------------- //
F2S.resize(CountFaces(), ivector1D(2, -1));

// ========================================================================== //
// GENERATE FACE DATA STRUCTURE                                               //
// ========================================================================== //
F = 0;
for (T = 0; T < nSimplex; ++T) {
    n = infos[e_type[T]].n_faces;
    for (i = 0; i < n; ++i) {
        if (flag[T][i]) {

            // Set simplex-face adjacency
            S2F[T][i] = F;
            A = Adjacency[T][i];
            if (A >= 0) {
                j = face(A, T);
                S2F[A][j] = F;
                flag[A][j] = false;
            }

            // Set face-simplex adjacency
            F2S[F][0] = T;
            F2S[F][1] = A;

            // Set flag
            flag[T][i] = false;

            // Update face counter
            F++;
        }
    } //next i
} //next T

return; };

// ========================================================================== //
// COUNTERS                                                                   //
// ========================================================================== //

// -------------------------------------------------------------------------- //
int Class_VolTri::CountIsolatedVertex(
    void
) {

// ========================================================================== //
// int Class_VolTri::CountIsolatedVertex(                                     //
//     void)                                                                  //
//                                                                            //
// Count isolated vertices. A vertex is isolated if there exist no simplex    //
// having a node in that vertex.                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of isolated vertices                              //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D             list;

// Counters
int                   n;
// ========================================================================== //
// COUNT ISOLATED VERTICES                                                    //
// ========================================================================== //
list = FindIsolatedVertex();
n = list.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountIsolatedVertex(
    a3vector2D              &V
) {

// ========================================================================== //
// int Class_VolTri::CountIsolatedVertex(                                     //
//     a3vector2D              &V)                                            //
//                                                                            //
// Count isolated vertices. A vertex is isolated if there exist no simplex    //
// having a node in that vertex. Vertex list is provided externally.          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V        : a3vector2D, vertex coordinate list. V[i][0], V[i][1], ...     //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of isolated vertices                              //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D                list;

// Counters
int                      n;

// ========================================================================== //
// COUNT ISOLATED VERTICES                                                    //
// ========================================================================== //
list = FindIsolatedVertex(V);
n = list.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountFreeVertex(
    void
) {

// ========================================================================== //
// int Class_VolTri::CountFreeVertex(                                         //
//     void)                                                                  //
//                                                                            //
// Count free vertexes in the tasselation. A free vertex is a vertex          //
// connected to a free face.                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of free vertices                                  //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D           list;

// Counters
int                 n;

// ========================================================================== //
// COUNT FREE VERTICES                                                        //
// ========================================================================== //
list = FindFreeVertex();
n = list.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountFreeVertex(
    a3vector2D              &V
) {

// ========================================================================== //
// int Class_VolTri::CountFreeVertex(                                         //
//     a3vector2D              &V)                                            //
//                                                                            //
// Count free vertexes in the tasselation. A free vertex is a vertex          //
// connected to a free face. Vertex list is provided externally.              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V        : a3vector2D, vertex coordinate list. V[i][0], V[i][1], ...     //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of free vertices                                  //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D           list;

// Counters
int                 n;

// ========================================================================== //
// COUNT FREE VERTICES                                                        //
// ========================================================================== //
list = FindFreeVertex(V);
n = list.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountDoubleVertex(
    void
) {

// ========================================================================== //
// int Class_SurfTri::CountDoubleVertex(                                      //
//     void)                                                                  //
//                                                                            //
// Count double vertices. A vertex is double if there exist another vertex    //
// having the same coordinates (within a prescribed tolerance).               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of isolated vertices                              //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D                 list;

// Counters
int                       n;

// ========================================================================== //
// COUNT DOUBLE VERTICES                                                      //
// ========================================================================== //
list = FindDoubleVertex();
n = list.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountDoubleVertex(
    a3vector2D              &V
) {

// ========================================================================== //
// int Class_SurfTri::CountDoubleVertex(                                      //
//     a3vector2D              &V)                                            //
//                                                                            //
// Count double vertices. A vertex is double if there exist another vertex    //
// having the same coordinates (within a prescribed tolerance).               //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V        : a3vector2D, vertex coordinate list. V[i][0], V[i][1], ...     //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of isolated vertices                              //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D                 list;

// Counters
int                       n;

// ========================================================================== //
// COUNT DOUBLE VERTICES                                                      //
// ========================================================================== //
list = FindDoubleVertex(V);
n = list.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountIsolatedSimplex(
    void
) {

// ========================================================================== //
// int Class_VolTri::CountIsolatedSimplex(                                    //
//     void)                                                                  //
//                                                                            //
// Count isolated simplex. A isolated simplex is a simplex  whose vertex are  //
// not shared by any of the other simplex.                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of isolated vertices                              //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D        List;

// Counters
int              n;

// ========================================================================== //
// COUNT ISOLATED SIMPLICIES                                                  //
// ========================================================================== //
List = FindIsolatedSimplex();
n = List.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountIsolatedSimplex(
    a3vector2D              &V
) {

// ========================================================================== //
// int Class_VolTri::CountIsolatedSimplex(                                    //
//     a3vector2D               &V)                                           //
//                                                                            //
// Count isolated simplex. A isolated simplex is a simplex  whose vertex are  //
// not shared by any of the other simplex.                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V        : a3vector2D, vertex coordinate list. V[i][0], V[i][1], ...     //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n        : int, number of isolated vertices                              //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D        List;

// Counters
int              n;

// ========================================================================== //
// COUNT ISOLATED SIMPLICIES                                                  //
// ========================================================================== //
List = FindIsolatedSimplex(V);
n = List.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountFreeSimplex(
    void
) {

// ========================================================================== //
// int Class_VolTri::CountFreeSimplex(                                        //
//     void)                                                                  //
//                                                                            //
// Count free simplex in the tasselation. A free simplex is a simplex having  //
// at least one free edge.                                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n     : int, number of free simplicies                                   //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D        List;

// Counters
int              n;

// ========================================================================== //
// COUNT FREE SIMPLICIES                                                      //
// ========================================================================== //
List = FindFreeSimplex();
n = List.size();

return(n); }

// -------------------------------------------------------------------------- //
int Class_VolTri::CountDoubleSimplex(
    void
) {

// ========================================================================== //
// int Class_VolTri::CountDoubleSimplex(                                      //
//     void)                                                                  //
//                                                                            //
// Count duplicated simplicies. A duplicated simplex is a simplex whose       //
// vertexes have coordinates coincident (within a prescribed  tolerance)      //
// with coordinates of vertices of another simplex.                           //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n    : int, number of duplicated simplicies.                             //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D         List;

// Counters
int               n;

// ========================================================================== //
// COUNT DOUBLE SIMPLICIES                                                    //
// ========================================================================== //
List = FindDoubleSimplex();
n = List.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountDoubleSimplex(
    a3vector2D              &X
) {

// ========================================================================== //
// int Class_VolTri::CountDoubleSimplex(                                      //
//     a3vector2D              &X)                                            //
//                                                                            //
// Count duplicated simplicies. A duplicated simplex is a simplex whose       //
// vertexes have coordinates coincident (within a prescribed  tolerance)      //
// with coordinates of vertices of another simplex. Vertex list is provided   //
// externally                                                                 //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X    : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are the //
//          x, y, ... coordinates of the i-th node.                           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n    : int, number of duplicated simplicies.                             //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D         List;

// Counters
int               n;

// ========================================================================== //
// COUNT DOUBLE SIMPLICIES                                                    //
// ========================================================================== //
List = FindDoubleSimplex(X);
n = List.size();

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountFaces(
    void
) {

// ========================================================================== //
// int Class_VolTri::CountFaces(                                              //
//     void)                                                                  //
//                                                                            //
// Count faces in a volume mesh.                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n     : int, number of faces                                             //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int    n, m, p;
double dcounter = 0.0;

// Counters
int    i, T;

// ========================================================================== //
// BUILD ADJACENCY IF NOT ALREADY BUILT                                       //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency();
}

// ========================================================================== //
// COUNT EDGES                                                                //
// ========================================================================== //

// Loop over simplicies
for (T = 0; T < nSimplex; T++) {
    p = infos[e_type[T]].n_faces;
    for (i = 0; i < p; i++) {
        if (Adjacency[T][i] >= 0) {
            dcounter += 0.5;
        }
        else {
            dcounter += 1.0;
        }
    } //next i
} //next T
n = (int) round(dcounter);

return(n); };

// -------------------------------------------------------------------------- //
int Class_VolTri::CountFreeFaces(
    void
) {

// ========================================================================== //
// int Class_VolTri::CountFreeFaces(                                          //
//     void)                                                                  //
//                                                                            //
// Count free faces in a volume mesh.                                         //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - n    : int, number of free faces.                                        //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int   n, m;

// Counters
int   i, j;

// ========================================================================== //
// BUILD ADJACENCY IF NOT ALREADY BUILT                                       //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency();
}

// ========================================================================== //
// COUNT FREE EDGES                                                           //
// ========================================================================== //

// Loop over simplicies
n = 0;
for (i = 0; i < nSimplex; i++){
    m = infos[e_type[i]].n_faces;
    for (j = 0; j < m; j++) {
        if (Adjacency[i][j] < 0) {
            n++;
        }
    } //next j
} //next i

return(n); }

// -------------------------------------------------------------------------- //
int Class_VolTri::Count0VolumeSimplex(
    void
) {

// ========================================================================== //
// int Class_VolTri::Count0VolumeSimplex(                                     //
//     void)                                                                  //
//                                                                            //
// Count 0-volume simplicies in the tasselation                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OTUTPUT                                                                    //
// ========================================================================== //
// - nS      : int, number of 0-volume simplicies                             //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double              V;
int                 nS = 0;

// Counters
int                 S;

// ========================================================================== //
// FIND 0-VOLUME SIMPLICIES                                                   //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    V = Volume(S);
    if (V < toll) { nS++; }
} //next S

return(nS); };

// -------------------------------------------------------------------------- //
int Class_VolTri::Count0VolumeSimplex(
    a3vector2D              &X
) {

// ========================================================================== //
// int Class_VolTri::Count0VolumeSimplex(                                     //
//     a3vector2D              &X)                                            //
//                                                                            //
// Count 0-volume simplicies in the tasselation using an external vertex list //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X       : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are  //
//             the x, y, ... coordinates of the i-th simplex.                 //
// ========================================================================== //
// OTUTPUT                                                                    //
// ========================================================================== //
// - nS      : int, number of 0-volume simplicies in the tasselation          //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double              V;
int                 nS = 0;

// Counters
int                 S;

// ========================================================================== //
// FIND 0-VOLUME SIMPLICIES                                                   //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    V = Volume(X, S);
    if (V < toll) { nS++; }
} //next S

return(nS); };

// ========================================================================== //
// FINDERS                                                                    //
// ========================================================================== //

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindIsolatedVertex(
    void
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindIsolatedVertex(                                //
//     void)                                                                  //
//                                                                            //
// Find isolated vertex. A node is isolated if there exist no simplex         //
// having a vertex in that node.                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   : ivector1D, global indices of isolated vertexes                  //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D       flag(nVertex, true);
ivector1D       list;

// Counters
int             i, I, m;

// ========================================================================== //
// FIND ISOLATED VERTEX                                                       //
// ========================================================================== //

// Loop over simplex
for (I = 0; I < nSimplex; I++) {
    m = infos[e_type[I]].n_vert;
    for (i = 0; i < m; i++) {
        flag[Simplex[I][i]] = false;
    }  //next i
} //next I

// Loop over vertexes
list.resize(count(flag.begin(), flag.end(), true));
i = 0;
for (I = 0; I < nVertex; I++) {
    if (flag[I]) {
        list[i] = I;
        i++;
    }
} //next I

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindIsolatedVertex(
    a3vector2D              &X
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindIsolatedVertex(                                //
//     a3vector2D              &X)                                            //
//                                                                            //
// Find isolated vertex. A node is isolated if there exist no simplex         //
// having a vertex in that node. Vertex coordinate list is provided           //
// externally.                                                                //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X   : a3vector2D, vertex coordinates. X[i][0], X[i][1], ... are the x,   //
//         y, ... coordinates of the i-th vertex.                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   : ivector1D, global indices of isolated vertexes                  //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D       flag(X.size(), true);
ivector1D       list;

// Counters
int             i, m, I;

// ========================================================================== //
// FIND ISOLATED VERTEX                                                       //
// ========================================================================== //

// Loop over simplex
for (I = 0; I < nSimplex; I++) {
    m = infos[e_type[I]].n_vert;
    for (i = 0; i < m; i++) {
        flag[Simplex[I][i]] = false;
    }  //next i
} //next I

// Loop over vertexes
list.resize(count(flag.begin(), flag.end(), true));
i = 0;
for (I = 0; I < X.size(); I++) {
    if (flag[I]) {
        list[i] = I;
        i++;
    }
} //next I

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindFreeVertex(
    void
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindFreeVertex(                                    //
//     void)                                                                  //
//                                                                            //
// Find free vertex in the tasselation. A free vertex is a vertex on          //
// mesh boundaries.                                                           //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   :ivector1D, global indices of free vertices                       //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D       flag(nVertex, false);
ivector1D       list, face_list;

// Counters
int             i, j, m, I, n;

// ========================================================================== //
// COMPUTE THE ADJACECNY MATRIX (IF NOT AREADY BUILT)                         //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency();
}

// ========================================================================== //
// COUNT FREE VERTEXES                                                        //
// ========================================================================== //

// Loop over simplex
for (I = 0; I < nSimplex; I++) {
    m = infos[e_type[I]].n_faces;
    for (i = 0; i < m; i++) {
        if (Adjacency[I][i] < 0) {
            face_list = FaceVertices(I, i);
            n = face_list.size();
            for (j = 0; j < n; j++) {
                flag[face_list[j]] = true;
            } //next j
        }
    } //next i
} //next I

// Loop over vertices
list.resize(count(flag.begin(), flag.end(), true));
i = 0;
for (I = 0; I < nVertex; I++) {
    if (flag[I]) {
        list[i] = I;
        i++;
    }
}

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindFreeVertex(
    a3vector2D              &X
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindFreeVertex(                                    //
//     a3vector2D              &X)                                            //
//                                                                            //
// Find free vertex in the tasselation. A free vertex is a vertex on          //
// mesh boundaries. Vertex list is provided externally.                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X   : a3vector2D, vertex coordinates. X[i][0], X[i][1], ... are the x,   //
//         y, ... coordinates of the i-th vertex.                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   :ivector1D, global indices of free vertices                       //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D       flag(X.size(), false);
ivector1D       list, face_list;

// Counters
int             i, j, m, I, n;

// ========================================================================== //
// COMPUTE THE ADJACECNY MATRIX (IF NOT AREADY BUILT)                         //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency(X);
}

// ========================================================================== //
// COUNT FREE VERTEXES                                                        //
// ========================================================================== //

// Loop over simplex
for (I = 0; I < nSimplex; I++) {
    m = infos[e_type[I]].n_faces;
    for (i = 0; i < m; i++) {
        if (Adjacency[I][i] < 0) {
            face_list = FaceVertices(I, i);
            n = face_list.size();
            for (j = 0; j < n; j++) {
                flag[face_list[j]] = true;
            } //next j
        }
    } //next i
} //next I

// Loop over vertices
list.resize(count(flag.begin(), flag.end(), true));
i = 0;
for (I = 0; I < nVertex; I++) {
    if (flag[I]) {
        list[i] = I;
        i++;
    }
}

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindDoubleVertex(
    int                      n
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindDoubleVertex(                                  //
//     int                      n)                                            //
//                                                                            //
// Find duplicated vertexes. A vertex is duplicated if there exist a simplex  //
// in the tasselation having a vertex with coordinates within a prescribed    //
// tolerance from the given vertex.                                           //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - n       : int (optional), number of bins for vertex sorting              //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - doublev : ivector1D, global indices of isolated vertices                 //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Variables declaration
int          m, ncell;
bvector1D    flag(nVertex, false);
ivector1D    index(nVertex, -1), idummy1D(2, -1);
ivector1D    doublev;
ivector3D    cell;

// Counters
int          I, C, S, V, W;
int          i;

// ========================================================================== //
// INITIALIZE VARIABLES                                                       //
// ========================================================================== //

// Random number generator -------------------------------------------------- //
srand(time(NULL));

// Resize variables --------------------------------------------------------- //
cell.resize(n*n*n);

// ========================================================================== //
// SORT VERTICES ON BINS                                                      //
// ========================================================================== //

// Sort vertices ------------------------------------------------------------ //
BinSortV(index, n);

// Sort simplicies ---------------------------------------------------------- //
for (I = 0; I < nSimplex; I++) {
    m = infos[e_type[I]].n_vert;
    for (i = 0; i < m; i++) {
        V = Simplex[I][i];
        C = index[V];
        idummy1D[0] = I;
        idummy1D[1] = i;
        cell[C].push_back(idummy1D);
    } //next i
} //next I

// ========================================================================== //
// FIND DOUBLE VERTICES                                                       //
// ========================================================================== //
ncell = cell.size();
{
    for (C = 0; C < ncell; C++) {
        m = cell[C].size();
        if (m > 0) {

            // Scope variables
            ivector1D    list;
            bitpit::KdTree<3, a3vector1D, int>     kd(m);

            // Randomize vertex insertion
            bitpit::utils::extractWithoutReplacement(m, m-1, list);
            for (I = 0; I < m; I++) {
                S = cell[C][list[I]][0];
                i = cell[C][list[I]][1];
                V = Simplex[S][i];
                if (kd.exist(&Vertex[V], W) >= 0) {
                    if (!flag[V]) {
                        flag[V] = true;
                        doublev.push_back(V);
                    }
                }
                else {
                    flag[V] = true;
                    kd.insert(&Vertex[V], V);
                }
            } //next I
        }
    } //next C
}

return (doublev); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindDoubleVertex(
    a3vector2D              &X,
    int                      n
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindDoubleVertex(                                  //
//     a3vector2D              &X,                                            //
//     int                      n)                                            //
//                                                                            //
// Find duplicated vertexes . A vertex is duplicated if there exist a simplex //
// having a vertex with coordinates within a prescribed tolerance from the    //
// given vertex.                                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X       : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are  //
//             the x, y, ... coordinates of the i-th vertex                   //
// - n       : int (optional), number of bins for vertex sorting              //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - doublev : ivector1D, global indices of isolated vertices                 //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Variables declaration
int          nV = X.size();
int          m, ncell;
bvector1D    flag(nV, false);
ivector1D    index(nV, -1), idummy1D(2, -1);
ivector1D    doublev;
ivector3D    cell;

// Counters
int          I, C, S, V, W;
int          i;

// ========================================================================== //
// INITIALIZE VARIABLES                                                       //
// ========================================================================== //

// Random number generator -------------------------------------------------- //
srand(time(NULL));

// Resize variables --------------------------------------------------------- //
cell.resize(n*n*n);

// ========================================================================== //
// SORT VERTICES ON BINS                                                      //
// ========================================================================== //

// Sort vertices ------------------------------------------------------------ //
BinSortV(index, n);

// Sort simplicies ---------------------------------------------------------- //
for (I = 0; I < nSimplex; I++) {
    m = Simplex[I].size();
    for (i = 0; i < m; i++) {
        V = Simplex[I][i];
        C = index[V];
        idummy1D[0] = I;
        idummy1D[1] = i;
        cell[C].push_back(idummy1D);
    } //next i
} //next I

// ========================================================================== //
// FIND DOUBLE VERTICES                                                       //
// ========================================================================== //
ncell = cell.size();
{
    for (C = 0; C < ncell; C++) {
        m = cell[C].size();
        if (m > 0) {

            // Scope variables
            ivector1D    list;
            bitpit::KdTree<3, a3vector1D, int>     kd(m);

            // Randomize vertex insertion
            bitpit::utils::extractWithoutReplacement(m, m-1, list);
            for (I = 0; I < m; I++) {
                S = cell[C][list[I]][0];
                i = cell[C][list[I]][1];
                V = Simplex[S][i];
                if (kd.exist(&X[V], W) >= 0) {
                    if (!flag[V]) {
                        flag[V] = true;
                        doublev.push_back(V);
                    }
                }
                else {
                    flag[V] = true;
                    kd.insert(&X[V], V);
                }
            } //next I
        }
    } //next C
}

return (doublev); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindIsolatedSimplex(
    void
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindIsolatedSimplex(                               //
//     void)                                                                  //
//                                                                            //
// Find isolated simplicies. A isolated simplex is a  simplex whose vertex    //
// are not shared by any other simplex                                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   :ivector1D, global indices of isolated simplicies                 //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D          flag(nSimplex, false);
ivector1D          flag_V(nVertex, 0);
ivector1D          list;
int                flag_T;

// Counters
int                i, j, m;

// ========================================================================== //
// COUNT ISOLATED SIMPLICIES                                                  //
// ========================================================================== //

// Compute vertex valence --------------------------------------------------- //
for (i = 0; i < nSimplex; i++) {
    m = infos[e_type[i]].n_vert;
    for (j = 0; j < m; j++) {
        flag_V[Simplex[i][j]] += 1;
    } //next j
} //next i

// Loop over simplicies ----------------------------------------------------- //
for (i = 0; i < nSimplex; i++) {
    flag[i] = true;
    j = 0;
    m = infos[e_type[i]].n_vert;
    while ((flag[i] == true) && (j < m)) {
        flag[i] = (flag[i] && (flag_V[Simplex[i][j]] == 1));
        j++;
    } //next j
} //next i

// Simplex list ------------------------------------------------------------- //
list.resize(count(flag.begin(), flag.end(), true));
j = 0;
for (i = 0; i < nSimplex; i++) {
    if (flag[i]) {
        list[j] = i;
        j++;
    }
} //next i

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindIsolatedSimplex(
    a3vector2D              &X
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindIsolatedSimplex(                               //
//     a3vector2D              &X)                                            //
//                                                                            //
// Find isolated simplicies. A isolated simplex is a simplex whose vertex     //
// are not shared by any other simplex. Vertex coordinate list is provided    //
// externally.                                                                //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X    : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are the //
//          x, y, ... coordinates of the i-th node.                           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   : ivector1D, global indices of isolated simplicies                //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D          flag(nSimplex, false);
ivector1D          flag_V(X.size(), 0);
ivector1D          list;
int                flag_T;

// Counters
int                i, j, m;

// ========================================================================== //
// COUNT ISOLATED SIMPLICIES                                                  //
// ========================================================================== //

// Compute vertex valence --------------------------------------------------- //
for (i = 0; i < nSimplex; i++) {
    m = Simplex[i].size();
    for (j = 0; j < m; j++) {
        flag_V[Simplex[i][j]] += 1;
    } //next j
} //next i

// Loop over simplicies ----------------------------------------------------- //
for (i = 0; i < nSimplex; i++) {
    flag[i] = true;
    j = 0;
    m = Simplex[i].size();
    while ((flag[i] == true) && (j < m)) {
        flag[i] = (flag[i] && (flag_V[Simplex[i][j]] == 1));
        j++;
    } //next j
} //next i

// Simplex list ------------------------------------------------------------- //
list.resize(count(flag.begin(), flag.end(), true));
j = 0;
for (i = 0; i < nSimplex; i++) {
    if (flag[i]) {
        list[j] = i;
        j++;
    }
} //next i

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindFreeSimplex(
    void
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindFreeSimplex(                                   //
//     void)                                                                  //
//                                                                            //
// Find free simplicies. A free simplex is a simplex having  at least one     //
// free face.                                                                 //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   : ivector1D, with global indices of free simplicies               //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D          flag(nSimplex, false);
ivector1D          list;

// Counters
int                i, j, m;

// ========================================================================== //
// COMPUTE ADJACENCY MATRIX IF NOT ALREADY COMPUTED                           //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency();
}

// ========================================================================== //
// FIND FREE SIMPLICIES                                                       //
// ========================================================================== //

// Loop over simplicies  ---------------------------------------------------- //
for (i = 0; i < nSimplex; i++) {
    m = infos[e_type[i]].n_faces;
    for (j = 0; j < m; j++) {
        flag[i] = (flag[i] || (Adjacency[i][j] < 0));
    } //next j
} //next i

// Simplex list ------------------------------------------------------------- //
list.resize(count(flag.begin(), flag.end(), true));
j = 0;
for (i = 0; i < nSimplex; i++) {
    if (flag[i]) {
        list[j] = i;
        j++;
    }
}

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindFreeSimplex(
    a3vector2D              &X
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindFreeSimplex(                                   //
//     a3vector2D              &X)                                            //
//                                                                            //
// Find free simplicies. A free simplex is a simplex having  at least one     //
// free face.                                                                 //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X      : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are   //
//            the x, y, ... coordinates of the i-th node.                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   : ivector1D, with global indices of free simplicies               //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bvector1D          flag(nSimplex, false);
ivector1D          list;

// Counters
int                i, j, m;

// ========================================================================== //
// COMPUTE ADJACENCY MATRIX IF NOT ALREADY COMPUTED                           //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency(X);
}

// ========================================================================== //
// FIND FREE SIMPLICIES                                                       //
// ========================================================================== //

// Loop over simplicies  ---------------------------------------------------- //
for (i = 0; i < nSimplex; i++) {
    m = infos[e_type[i]].n_faces;
    for (j = 0; j < m; j++) {
        flag[i] = (flag[i] || (Adjacency[i][j] < 0));
    } //next j
} //next i

// Simplex list ------------------------------------------------------------- //
list.resize(count(flag.begin(), flag.end(), true));
j = 0;
for (i = 0; i < nSimplex; i++) {
    if (flag[i]) {
        list[j] = i;
        j++;
    }
}

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindDoubleSimplex(
    void
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindDoubleSimplex(                                 //
//     void)                                                                  //
//                                                                            //
// Find douplicated simplex.                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   : ivector1D, list of duplicated simplicies                        //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bool                    check;
bvector1D               flag(nSimplex, false);
ivector1D               idummy1D, doubles;
ivector2D               index(nVertex);

// Counters
int                     V, T, S;
int                     i, j, k, l, ii;
int                     m, n, p;

// ========================================================================== //
// 1-RING OF VERTICES                                                         //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    m = Simplex[T].size();
    for (i = 0; i < m; i++) {
        V = Simplex[T][i];
        index[V].push_back(T);
    } //next i
} //next T

// ========================================================================== //
// FIND DUPLICATED SIMPLICIES                                                 //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    if (!flag[T]) {
        flag[T] = true;
        m = Simplex[T].size();
        for (i = 0; i < m; i++) {
            V = Simplex[T][i];
            n = index[V].size();
            for (j = 0; j < n; j++) {
                S = index[V][j];
                p = Simplex[S].size();
                if ((p == m) && (!flag[S])) {
                    check = SameSimplex(T, S);
                    if (check) {
                        doubles.push_back(S);
                        flag[S] = true;
                    }
                }
            } //next j
        } //next i
    }
} //next T

return(doubles); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::FindDoubleSimplex(
    a3vector2D              &X
) {

// ========================================================================== //
// ivector1D Class_VolTri::FindDoubleSimplex(                                 //
//     a3vector2D              &X)                                            //
//                                                                            //
// Find douplicated simplex. Vertex list is provided externally.              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X      : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are   //
//            the x, y, ... coordinates of the i-th vertex.                   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - list   : ivector1D, list of duplicated simplicies                        //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bool                    check;
bvector1D               flag(nSimplex, false);
ivector1D               idummy1D, doubles;
ivector2D               index(X.size());

// Counters
int                     V, S, T;
int                     i, j, k, l, ii;
int                     m, n, p;

// ========================================================================== //
// 1-RING OF VERTICES                                                         //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    m = Simplex[T].size();
    for (i = 0; i < m; i++) {
        V = Simplex[T][i];
        index[V].push_back(T);
    } //next i
} //next T

// ========================================================================== //
// FIND DUPLICATED VERTICES                                                   //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    if (!flag[T]) {
        flag[T] = true;
        m = Simplex[T].size();
        for (i = 0; i < m; i++) {
            V = Simplex[T][i];
            n = index[V].size();
            for (j = 0; j < n; j++) {
                S = index[V][j];
                p = Simplex[S].size();
                if ((p == m) && (!flag[S])) {
                    check = SameSimplex(T, S);
                    if (check) {
                        doubles.push_back(S);
                        flag[S] = true;
                    }
                }
            } //next j
        } //next i
    }
} //next T

return(doubles); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::Find0VolumeSimplex(
    void
) {

// ========================================================================== //
// ivector1D Class_VolTri::Find0VolumeSimplex(                                //
//     void)                                                                  //
//                                                                            //
// Find 0-volume simplicies in the tasselation                                //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OTUTPUT                                                                    //
// ========================================================================== //
// - list    : ivector1D, 0-volume simplex list                               //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double              V;
ivector1D           list;

// Counters
int                 S;

// ========================================================================== //
// FIND 0-VOLUME SIMPLICIES                                                   //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    V = Volume(S);
    if (V < toll) { list.push_back(S); }
} //next S

return(list); };

// -------------------------------------------------------------------------- //
ivector1D Class_VolTri::Find0VolumeSimplex(
    a3vector2D              &X
) {

// ========================================================================== //
// ivector1D Class_VolTri::Find0VolumeSimplex(                                //
//     a3vector2D              &X)                                            //
//                                                                            //
// Find 0-volume simplicies in the tasselation using an external vertex list  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X       : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are  //
//             the x, y, ... coordinates of the i-th simplex.                 //
// ========================================================================== //
// OTUTPUT                                                                    //
// ========================================================================== //
// - list    : ivector1D, 0-volume simplex list                               //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double              V;
ivector1D           list;

// Counters
int                 S;

// ========================================================================== //
// FIND 0-VOLUME SIMPLICIES                                                   //
// ========================================================================== //
for (S = 0; S < nSimplex; ++S) {
    V = Volume(X, S);
    if (V < toll) { list.push_back(S); }
} //next S

return(list); };

// ========================================================================== //
// CLEANERS                                                                   //
// ========================================================================== //

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveVertex(
    ivector1D   &list
) {

// ========================================================================== //
// void Class_VolTri::RemoveVertex(                                           //
//     ivector1D   &list)                                                     //
//                                                                            //
// Remove vertex from mesh.                                                   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - list   : ivector1D, list with global index of removable node.            //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLE DECLARATION                                                       //
// ========================================================================== //

// Local variables
ivector1D              map(nVertex, 0);

// Counters
int                    counter = 0;
int                    i, j, m;

// ========================================================================== //
// REMOVE VERTEX FROM THE VERTEX LIST                                         //
// ========================================================================== //

// Initialize variables ----------------------------------------------------- //

    // vertex mapper
    for(i = 0; i < nVertex; i++) {
        map[i] = i;
    } //next i
    m = list.size();
    for (i = 0; i < m; i++) {
        map[list[i]] = -1;
    } //next i


// Re-map node positions in the vertex list --------------------------------- //

    // Update vertex list
    j = 0;
    for (i = 0; i < nVertex; i++) {
        if (map[i] >= 0) {
            counter++;
            Vertex[j] = Vertex[i];
            map[i] = j;
            j++;
        }
    } //next i

    // Update vertex number
    nVertex = counter;

    // Update simplex-vertex connectivity
    for (i = 0; i < nSimplex; i++) {
        m = Simplex[i].size();
        for (j = 0; j < m; j++) {
            Simplex[i][j] = map[Simplex[i][j]];
        } //next j
    } //next i

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveVertex(
    ivector1D   &list,
    ivector1D   &map
) {

// ========================================================================== //
// void Class_VolTri::RemoveVertex(                                           //
//     ivector1D   &list,                                                     //
//     ivector1D   &map)                                                      //
//                                                                            //
// Remove vertex from the tasselation, renumber tasselation vertexes and      //
// returns a mapper between old and new numeration                            //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - list   : ivector1D, list with global indices of removable nodes.         //
// - map    : ivector1D, map old -> new vertices. map[i] stores               //
//            the global index of the i-th vertex after renumbering.          //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLE DECLARATION                                                       //
// ========================================================================== //

// Local variables
// none

// Counters
int                    counter = 0;
int                    i, j, m;

// ========================================================================== //
// RESIZE OUTPUT VARIABLES                                                    //
// ========================================================================== //
map.resize(nVertex, 0);

// ========================================================================== //
// REMOVE VERTEX FROM THE VERTEX LIST                                         //
// ========================================================================== //

// Initialize variables ----------------------------------------------------- //

    // vertex mapper
    for(i = 0; i < nVertex; i++) {
        map[i] = i;
    } //next i
    m = list.size();
    for (i = 0; i < m; i++) {
        map[list[i]] = -1;
    } //next i



// Re-map node positions in the vertex list --------------------------------- //

    // Update vertex list
    j = 0;
    for (i = 0; i < nVertex; i++) {
        if (map[i] >= false) {
            counter++;
            Vertex[j] = Vertex[i];
            map[i] = j;
            j++;
        }
    } //next i

    // Update vertex number
    nVertex = counter;

    // Update simplex-vertex connectivity
    for (i = 0; i < nSimplex; i++) {
        m = Simplex[i].size();
        for (j = 0; j < m; j++) {
            Simplex[i][j] = map[Simplex[i][j]];
        } //next j
    } //next i

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::CollapseDoubleVertex(
    ivector1D   &doublev,
    int          n
) {

// ========================================================================== //
// ivector1D Class_VolTri::CollapseDoubleVertex(                              //
//     ivector1D   &doublev,                                                  //
//     int          n)                                                        //
//                                                                            //
// Collapse double vertices.                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - doublev      : ivector1D, list with collapsed vertices                   //
// - n            : int (optional), number of bins for bin sorting            //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Variables declaration
int          m, ncell;
bvector1D    flag(nVertex, false);
ivector1D    index(nVertex, -1), idummy1D(2, -1);
ivector3D    cell;

// Counters
int          I, C, S, V, W;
int          i;

// ========================================================================== //
// INITIALIZE VARIABLES                                                       //
// ========================================================================== //

// Random number generator -------------------------------------------------- //
srand(time(NULL));

// Resize variables --------------------------------------------------------- //
cell.resize(n*n*n);

// List of collapsed vertices ----------------------------------------------- //
doublev.resize(0);

// ========================================================================== //
// SORT VERTICES ON BINS                                                      //
// ========================================================================== //

// Sort vertices ------------------------------------------------------------ //
BinSortV(index, n);

// Sort simplicies ---------------------------------------------------------- //
for (I = 0; I < nSimplex; I++) {
    m = Simplex[I].size();
    for (i = 0; i < m; i++) {
        V = Simplex[I][i];
        C = index[V];
        idummy1D[0] = I;
        idummy1D[1] = i;
        cell[C].push_back(idummy1D);
    } //next i
} //next I

// ========================================================================== //
// COLLAPSE DOUBLE VERTICES                                                   //
// ========================================================================== //
ncell = cell.size();
{
    for (C = 0; C < ncell; C++) {
        m = cell[C].size();
        if (m > 0) {

            // Scope variables
            ivector1D    list;
            bitpit::KdTree<3, a3vector1D, int>     kd(m);

            // Randomize vertex insertion
            bitpit::utils::extractWithoutReplacement(m, m-1, list);
            for (I = 0; I < m; I++) {
                S = cell[C][list[I]][0];
                i = cell[C][list[I]][1];
                V = Simplex[S][i];
                if (kd.exist(&Vertex[V], W) >= 0) {
                    Simplex[S][i] = W;
                    if (!flag[V]) {
                        flag[V] = true;
                        doublev.push_back(V);
                    }
                }
                else {
                    flag[V] = true;
                    kd.insert(&Vertex[V], V);
                }
            } //next I
        }
    } //next C
}

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::CollapseDoubleVertex(
    a3vector2D  &X,
    ivector1D   &doublev,
    int          n
) {

// ========================================================================== //
// ivector1D Class_VolTri::CollapseDoubleVertex(                              //
//     a3vector2D  &X,                                                        //
//     ivector1D   &doublev,                                                  //
//     int          n)                                                        //
//                                                                            //
// Collapse double vertices, using an external vertex list.                   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X            : a3vector2D, external vertex list. X[i][0], X[i][1], ...   //
//                  are the x, y, ... components of the i-th vertex           //
// - doublev      : ivector1D, list of collapsed vertices                     //
// - n            : int (optional), number of bins for bin sorting            //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Variables declaration
int          nV = X.size();
int          m, ncell;
bvector1D    flag(nV, false);
ivector1D    index(nV, -1), idummy1D(2, -1);
ivector3D    cell;

// Counters
int          I, C, S, V, W;
int          i;

// ========================================================================== //
// INITIALIZE VARIABLES                                                       //
// ========================================================================== //

// Random number generator -------------------------------------------------- //
srand(time(NULL));

// Resize variables --------------------------------------------------------- //
cell.resize(n*n*n);

// ========================================================================== //
// SORT VERTICES ON BINS                                                      //
// ========================================================================== //

// Sort vertices ------------------------------------------------------------ //
BinSortV(X, index, n);

// Sort simplicies ---------------------------------------------------------- //
for (I = 0; I < nSimplex; I++) {
    m = Simplex[I].size();
    for (i = 0; i < m; i++) {
        V = Simplex[I][i];
        C = index[V];
        idummy1D[0] = I;
        idummy1D[1] = i;
        cell[C].push_back(idummy1D);
    } //next i
} //next I

// ========================================================================== //
// COLLAPSE DOUBLE VERTICES                                                   //
// ========================================================================== //
ncell = cell.size();
{
    for (C = 0; C < ncell; C++) {
        m = cell[C].size();
        if (m > 0) {

            // Scope variables
            ivector1D    list;
            bitpit::KdTree<3, a3vector1D, int>     kd(m);

            // Randomize vertex insertion
            bitpit::utils::extractWithoutReplacement(m, m-1, list);
            for (I = 0; I < m; I++) {
                S = cell[C][list[I]][0];
                i = cell[C][list[I]][1];
                V = Simplex[S][i];
                if (kd.exist(&X[V], W) >= 0) {
                    Simplex[S][i] = W;
                    if (!flag[V]) {
                        flag[V] = true;
                        doublev.push_back(V);
                    }
                }
                else {
                    flag[V] = true;
                    kd.insert(&X[V], V);
                }
            } //next I
        }
    } //next C
}

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveSimplex(
    ivector1D   &list
) {

// ========================================================================== //
// void Class_VolTri::RemoveSimplex(                                          //
//     ivector1D   &list)                                                     //
//                                                                            //
// Remove simplicies from the simplex list.                                   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - list   : ivector1D, list with global indices of removable simplicies.    //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D    map(nSimplex, 0);

// Counter
int          counter;
int          I, J;
int          i, j, m;

// Initialize variables ----------------------------------------------------- //
for (i = 0; i < nSimplex; i++) {
    map[i] = i;
} //next i
m = list.size();
for (i = 0; i < list.size(); i++) {
    map[list[i]] = -1;
}

// Loop over simplicies ----------------------------------------------------- //
J = 0;
counter = 0;
for (I = 0; I < nSimplex; I++) {
    if (map[I] >= 0) {

        // Update counter
        counter++;

        // Update simplex-vertex connectivity
        Simplex[J].resize(Simplex[I].size());
        Simplex[J] = Simplex[I];

        // Update element type
        e_type[J] = e_type[I];

        // Update map
        map[I] = J;

        // Update counter
        J++;

    }
} //next I

// Update Adjacency --------------------------------------------------------- //
if ((Adjacency.size() > 0) && (Adjacency.size() >= nSimplex)) {
    for (I = 0; I < nSimplex; I++) {
        if (map[I] >= 0) {

            // Update simplex-simplex connectivity
            m = Adjacency[I].size();
            Adjacency[map[I]].resize(m, -1);
            for (i = 0; i < m; i++) {
                J = Adjacency[I][i];
                if (J >= 0) {
                    Adjacency[map[I]][i] = map[J];
                }
                else {
                    Adjacency[map[I]][i] = -1;
                }
            } //next i

        }
    } // next I
}

// Update number of simplicies ---------------------------------------------- //
nSimplex = counter;

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveSimplex(
    ivector1D   &list,
    ivector1D   &map
) {

// ========================================================================== //
// void Class_VolTri::RemoveSimplex(                                          //
//     ivector1D   &list,                                                     //
//     ivector1D   &map)                                                      //
//                                                                            //
// Remove simplicies from simplex list, renumber simplicies and returns       //
// mapper between old and new numeration                                      //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - list  : ivector1D, list with global index of removable simplicies.       //
// - map   : ivector1D, with old -> new map. map[i] contains the              //
//           global index of the i-th simplex after renumbering               //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counter
int          counter;
int          I, J;
int          i, j, m;

// Initialize variables ----------------------------------------------------- //
map.resize(nSimplex,-0);
for (i = 0; i < nSimplex; i++) {
    map[i] = i;
}
m = list.size();
for (i = 0; i < m; i++) {
    map[list[i]] = -1;
} //next i

// Loop over simplicies ----------------------------------------------------- //
J = 0;
counter = 0;
for (I = 0; I < nSimplex; I++) {
    if (map[I] >= 0) {

        // Update counter
        counter++;

        // Update simplex-vertex connectivity
        Simplex[J].resize(Simplex[I].size());
        Simplex[J] = Simplex[I];

        // Update element type
        e_type[J] = e_type[I];

        // Update map
        map[I] = J;

        // Update counter
        J++;

    }
} //next I

// Update Adjacency --------------------------------------------------------- //
if ((Adjacency.size() > 0) && (Adjacency.size() >= nSimplex)) {
    for (I = 0; I < nSimplex; I++) {
        if (map[I] >= 0) {

            // Update simplex-simplex connectivity
            m = Adjacency[I].size();
            Adjacency[map[I]].resize(m, -1);
            for (i = 0; i < m; i++) {
                J = Adjacency[I][i];
                if (J >= 0) {
                    Adjacency[map[I]][i] = map[J];
                }
            } // next i

        }
    } // next I
}

// Update number of simplicies ---------------------------------------------- //
nSimplex = counter;

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri:: RemoveIsolatedVertex(
    void
) {

// ========================================================================== //
// void Class_VolTri:: RemoveIsolatedVertex(                                  //
//     void)                                                                  //
//                                                                            //
// Remove isolated vertex. A vertex is isolated if and  only if thera are no  //
// simplicies having a vertex in that node.                                   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D      list;

// Counters
// none

// ========================================================================== //
// FIND ISOLATED VERTEX                                                       //
// ========================================================================== //
list = FindIsolatedVertex();

// ========================================================================== //
// REMOVE VERTEX                                                              //
// ========================================================================== //
RemoveVertex(list);

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri:: RemoveIsolatedVertex(
    ivector1D   &map
) {

// ========================================================================== //
// void Class_VolTri:: RemoveIsolatedVertex(                                  //
//     ivector1D   &map)                                                      //
//                                                                            //
// Remove isolated vertex, and returns map between old and new numeration.    //
// A vertex is isolated if and only if thera are no simplicies having a       //
// vertex in that node.                                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - map    : ivector1D, map old -> new vertexes. map[i] stores the           //
//            global index of the i-th vertex after renumbering.              //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D      list;

// Counters
// none

// ========================================================================== //
// FIND ISOLATED VERTEX                                                       //
// ========================================================================== //
list = FindIsolatedVertex();

// ========================================================================== //
// REMOVE VERTEX                                                              //
// ========================================================================== //
RemoveVertex(list, map);

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveDoubleVertex(
    int          n
) {

// ========================================================================== //
// void Class_VolTri::RemoveDoubleVertex(                                     //
//     int          n)                                                        //
//                                                                            //
// Remove double vertices.                                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - n         : int (optional) number of bins for vertex sorting             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D            list;

// Counters
// none

// ========================================================================== //
// COLLAPSE DOUBLE VERTEX                                                     //
// ========================================================================== //
CollapseDoubleVertex(list, n);

// ========================================================================== //
// REMOVE COLLAPSED VERTEX                                                    //
// ========================================================================== //
RemoveVertex(list);

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveDoubleVertex(
    ivector1D   &map,
    int          n
) {

// ========================================================================== //
// void Class_VolTri::RemoveDoubleVertex(                                     //
//     ivector1D   &map,                                                      //
//     int          n)                                                        //
//                                                                            //
// Remove double vertices, and returns renumbering map                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - map    : ivector1D, map old -> new vertexes. map[i] stores the           //
//            global index of the i-th vertex after renumbering.              //
// - n      : int (optional), number of bins used for vertex sorting          //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D            list;

// Counters
// none

// ========================================================================== //
// COLLAPSE DOUBLE VERTEX                                                     //
// ========================================================================== //
CollapseDoubleVertex(list, n);

// ========================================================================== //
// REMOVE COLLAPSED VERTEX                                                    //
// ========================================================================== //
RemoveVertex(list, map);

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveIsolatedSimplex(
    void
) {

// ========================================================================== //
// void Class_VolTri::RemoveIsolatedSimplex(                                  //
//     void)                                                                  //
//                                                                            //
// Remove isolated simplicies. A isolated simplex is a simplex whose vertices //
// are not shared by any other simplex.                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D   list;

// Counters
// none

// ========================================================================== //
// REMOVE ISOLATED SIMPLICIES                                                 //
// ========================================================================== //

// Find isolated simplicies
list = FindIsolatedSimplex();

// Remove simplicies
RemoveSimplex(list);

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveIsolatedSimplex(
    ivector1D   &map
) {

// ========================================================================== //
// void Class_VolTri::RemoveIsolatedSimplex(                                  //
//     ivector1D   &map)                                                      //
//                                                                            //
// Remove isolated simplicies, and returns map between old and new numeration.//
// A isolated simplex is a simplex whose vertex are not shared by any other   //
// simplex.                                                                   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - map   : ivector1D, with old -> new map. map[i] contains the              //
//           global index of the i-th vertex after renumbering                //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D   list;

// Counters
// none

// ========================================================================== //
// REMOVE ISOLATED SIMPLICIES                                                 //
// ========================================================================== //

// Find isolated simplicies
list = FindIsolatedSimplex();

// Remove simplicies
RemoveSimplex(list, map);

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveIsolatedSimplex(
    a3vector2D  &X
) {

// ========================================================================== //
// void Class_VolTri::RemoveIsolatedSimplex(                                  //
//     a3vector2D  &X)                                                        //
//                                                                            //
// Remove isolated simplicies. A isolated simplex is a simplex whose vertex   //
// are not shared by any other simplex in the tasselation. Vertex coordinate  //
// list is provided externally.                                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X    : a3vector2D, vertex coordinate list. X[i][0], X[i][1],             //
//          ... are the x, y, ... coordinates of the i-th node.               //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D   list;

// Counters
// none

// ========================================================================== //
// REMOVE ISOLATED SIMPLICIES                                                 //
// ========================================================================== //
list = FindIsolatedSimplex(X);
RemoveSimplex(list);

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveDoubleSimplex(
    void
) {

// ========================================================================== //
// void Class_VolTri::RemoveDoubleSimplex(                                    //
//     void)                                                                  //
//                                                                            //
// Remove duplicated simplicies. A duplicated simplex is a simplex having the //
// same vertices of another simplex.                                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D    list;

// Counters
// none

// ========================================================================== //
// REMOVE DUPLICATED SIMPLICIES                                               //
// ========================================================================== //

// Find double simplicies
list = FindDoubleSimplex();

// Remove simplicies
RemoveSimplex(list);

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveDoubleSimplex(
    ivector1D   &map
) {

// ========================================================================== //
// void Class_VolTri::RemoveDoubleSimplex(                                    //
//     ivector1D   &map)                                                      //
//                                                                            //
// Remove duplicated simplicies, and return renumbering map. A duplicated     //
// simplex is a simplex having the same vertices of another simplex.          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - map   : ivector1D, map between old and new simplex numbering             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D    list;

// Counters
// none

// ========================================================================== //
// REMOVE DUPLICATED SIMPLICIES                                               //
// ========================================================================== //

// Find double simplicies
list = FindDoubleSimplex();

// Remove simplicies
RemoveSimplex(list, map);

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::RemoveDoubleSimplex(
    a3vector2D  &X
) {

// ========================================================================== //
// void Class_VolTri::RemoveDoubleSimplex(                                    //
//     a3vector2D   &X)                                                       //
//                                                                            //
// Remove duplicated simplicies using an external vertex list. A duplicated   //
// simplex is a simplex having the same vertices of another simplex.          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X  : a3vector2D, with vertex coordinate list. X[i][0], X[i][1], ... are  //
//        the x, y, ... coordinates of the i-th node.                         //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D    list;

// Counters
// none

// ========================================================================== //
// REMOVE DUPLICATED SIMPLICIES                                               //
// ========================================================================== //

// Find double simplicies
list = FindDoubleSimplex(X);

// Remove simplicies
RemoveSimplex(list);

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::Remove0VolumeSimplex(
    void
) {

// ========================================================================== //
// void Class_VolTri::Remove0VolumeSimplex(                                   //
//     void)                                                                  //
//                                                                            //
// Remove 0 volume simplicies from tasselation.                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D           list;

// Counters
// none

// ========================================================================== //
// REMOVE 0 VOLUME SIMPLICIES                                                 //
// ========================================================================== //
list = Find0VolumeSimplex();
RemoveSimplex(list);

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::Remove0VolumeSimplex(
    a3vector2D  &X
) {

// ========================================================================== //
// void Class_VolTri::Remove0VolumeSimplex(                                   //
//     a3vector2D  &X)                                                        //
//                                                                            //
// Remove 0 volume simplicies from tasselation, using an external vertex list //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X    : a3vector2D, vertex coordinate list. X[i][0], X[i][1], ... are the //
//          x, y, ... coordinates of the i-th simplex.                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
ivector1D           list;

// Counters
// none

// ========================================================================== //
// REMOVE 0 VOLUME SIMPLICIES                                                 //
// ========================================================================== //
list = Find0VolumeSimplex(X);
RemoveSimplex(list);

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::Clean(
    void
) {

// ========================================================================== //
// void Class_VolTri::Clean(                                                  //
//     void)                                                                  //
//                                                                            //
// Clean mesh from topology errors.                                           //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bool            check_adjacency;

// Counters
// none

// ========================================================================== //
// CLEAN TASSELATION FROM REPEATED VERTEX                                     //
// ========================================================================== //

// Set tollerance
SetTolerance();

// Veriables to be reshaped
check_adjacency = ((Adjacency.size() > 0) && (Adjacency.size() >= nSimplex));

// Clean
RemoveDoubleVertex();
Remove0VolumeSimplex();
RemoveIsolatedSimplex();
RemoveIsolatedVertex();
RemoveDoubleSimplex();

// Resize
ResizeVertex();
ResizeSimplex();
if (check_adjacency) {
    ResizeAdjacency();
}

return; };

// -------------------------------------------------------------------------- //
void Class_VolTri::Clean(
    a3vector2D  &X
) {

// ========================================================================== //
// void Class_VolTri::Clean(                                                  //
//     a3vector2D  &X)                                                        //
//                                                                            //
// Clean mesh from repeated vertex and repeated simplex.                      //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - X    : a3vector2D, vertex coordinate list. X[i][0], X[i][1],             //
//          ... are the x, y, ... coordinates of the i-th node.               //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bool            check_adjacency;
ivector1D       list;

// Counters
// none

// ========================================================================== //
// CLEAN TASSELATION FROM REPEATED VERTEX                                     //
// ========================================================================== //

// Set tollerance
SetTolerance(X);

// Veriables to be reshaped
check_adjacency = ((Adjacency.size() > 0) && (Adjacency.size() >= nSimplex));

// Clean
CollapseDoubleVertex(X, list);
Remove0VolumeSimplex(X);
RemoveIsolatedSimplex(X);
RemoveDoubleSimplex(X);

// Resize
ResizeVertex();
ResizeSimplex();
if (check_adjacency) {
    ResizeAdjacency();
}

return; };

// ========================================================================== //
// MESH STATS                                                                 //
// ========================================================================== //

// -------------------------------------------------------------------------- //
void Class_VolTri::Stats(
    ostream     &out
) {

// ========================================================================== //
// void Class_VolTri::Stats(                                                  //
//     ostream     &out)                                                      //
//                                                                            //
// Compute mesh stats.                                                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - out      : ostream, output stream                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int             n;
stringstream    msg;

// Counters
// none

// ========================================================================== //
// UPDATE ADJACENCY MATRIX                                                    //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency();
}

// ========================================================================== //
// VERTEX STATS                                                               //
// ========================================================================== //
out << "  Vertex ----------------------------------"   << endl;
out << "    # vertex       " << nVertex                << endl;
out << "    # isol. vertex " << CountIsolatedVertex()  << endl;
out << "    # free  vertex " << CountFreeVertex()      << endl;
out << "    # dupl. vertex " << CountDoubleVertex()    << endl;

// ========================================================================== //
// EDGE STATS                                                                 //
// ========================================================================== //
out << "  Faces -----------------------------------"   << endl;
out << "    # faces        " << CountFaces()           << endl;
out << "    # free  faces  " << CountFreeFaces()       << endl;

// ========================================================================== //
// SIMPLEX STATS                                                              //
// ========================================================================== //
out << "  Simplicies ------------------------------"   << endl;
out << "    # simplicies   " << nSimplex               << endl;
out << "    # isol. simpl. " << CountIsolatedSimplex() << endl;
out << "    # free  simpl. " << CountFreeSimplex()     << endl;
out << "    # dupl. simpl. " << CountDoubleSimplex()   << endl;

return; }

// -------------------------------------------------------------------------- //
void Class_VolTri::Stats(
    ostream     &out,
    a3vector2D  &X
) {

// ========================================================================== //
// void Class_VolTri::Stats(                                                  //
//     ostream     &out,                                                      //
//     a3vector2D  &X)                                                        //
//                                                                            //
// Compute mesh stats. Vertex coordinate list is provided externally          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - out    : ostream, output stream                                          //
// - X      : a3vector2D, with vertex coordinate list. X[i][0], X[i][1], ...  //
//            are the x, y, ... coordinates of the i-th node.                 //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int             n;
stringstream    msg;

// Counters
// none

// ========================================================================== //
// UPDATE ADJACENCY MATRIX                                                    //
// ========================================================================== //
if ((Adjacency.size() == 0) || (Adjacency.size() < nSimplex)) {
    BuildAdjacency(X);
}

// ========================================================================== //
// VERTEX STATS                                                               //
// ========================================================================== //
out << "  Vertex ----------------------------------"    << endl;
out << "    # vertex       " << nVertex                 << endl;
out << "    # isol. vertex " << CountIsolatedVertex(X)  << endl;
out << "    # free  vertex " << CountFreeVertex(X)      << endl;
out << "    # dupl. vertex " << CountDoubleVertex(X)    << endl;

// ========================================================================== //
// EDGE STATS                                                                 //
// ========================================================================== //
out << "  Faces -----------------------------------"    << endl;
out << "    # faces        " << CountFaces()            << endl;
out << "    # free  faces  " << CountFreeFaces()        << endl;

// ========================================================================== //
// SIMPLEX STATS                                                              //
// ========================================================================== //
out << "  Simplicies ------------------------------"    << endl;
out << "    # simplicies   " << nSimplex                << endl;
out << "    # isol. simpl. " << CountIsolatedSimplex(X) << endl;
out << "    # free  simpl. " << CountFreeSimplex()      << endl;
out << "    # dupl. simpl. " << CountDoubleSimplex(X)   << endl;

return; }

