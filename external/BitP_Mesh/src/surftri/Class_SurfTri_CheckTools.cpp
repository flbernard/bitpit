// ========================================================================== //
//                         - Class_SurfTri -                                  //
//                                                                            //
// Grid manager for unstructured meshes.                                      //
// ========================================================================== //
// INFO                                                                       //
// ========================================================================== //
// Author   : Alessandro Alaia                                                //
// Version  : v3.0                                                            //
//                                                                            //
// All rights reserved.                                                       //
// ========================================================================== //

// ========================================================================== //
// INCLUDES                                                                   //
// ========================================================================== //
# include "Class_SurfTri.hpp"

// ========================================================================== //
// GLOBAL CONSTANTS                                                           //
// ========================================================================== //
double const      pi = 3.14159265358979;

// ========================================================================== //
// IMPLEMENTATIONS                                                            //
// ========================================================================== //

// -------------------------------------------------------------------------- //
darray3E Class_SurfTri::Baricenter(
    int          T
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Baricenter(                                       //
//     int          T)                                                        //
//                                                                            //
// Compute simplex baricenter.                                                //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T     : int, simplex global index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P     : dvector1D, with simplex baricenter coordinates                   //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int            dim = Vertex[0].size();
darray3E      P;
P.fill(0.) ;

// Counters
int            i, m;

// ========================================================================== //
// COMPUTE SIMPLEX BARICENTER                                                 //
// ========================================================================== //
m = Simplex[T].size();
for (i = 0; i < m; i++) {
    P = P + Vertex[Simplex[T][i]] ;
} //next i

P = P/((double) m);

return(P); };

// -------------------------------------------------------------------------- //
darray3E Class_SurfTri::Baricenter(
    int          T,
    dvecarr3E   &V
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Baricenter(                                       //
//     int          T,                                                        //
//     dvecarr3E   &V)                                                        //
//                                                                            //
// Compute simplex baricenter. Vertex coordinate list is provided externally  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T     : int, simplex global index                                        //
// - V        : dvecarr3E with vertex coordinate list. X[i][0], X[i][1], ...  //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P     : dvector1D, with simplex baricenter coordinates                   //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int            dim = V[0].size();
darray3E       P;
P.fill(0.0) ;

// Counters
int            i, m; 

// ========================================================================== //
// COMPUTE SIMPLEX BARICENTER                                                 //
// ========================================================================== //
m = Simplex[T].size();
for (i = 0; i < m; i++) {
    P = P + V[Simplex[T][i]] ;
} //next i

P = P/((double) m);

return(P); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the minimal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// min edge.                                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - edge      : double, minimal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
minEdge(T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    minEdge(I_, ddummy, j);
    if (ddummy < edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    dvecarr3E   &V,
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     dvecarr3E   &V,                                                        //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the minimal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// min edge. Vertex list is provided externally.                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V         : dvecarr3E; vertex coordinate list. V[i][0], V[i][1], ...     //
//               are the x, y, ... coordinates of the i-th vertex             //
// - edge      : double, minimal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
minEdge(V, T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    minEdge(V, I_, ddummy, j);
    if (ddummy < edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &i)                                                        //
//                                                                            //
// Return length of simplex' minimal edge.                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T    : int, simplex global index                                         //
// - edge : double, min edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int            dim = Vertex[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm2(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm2(Vertex[Simplex[T][k]] - Vertex[Simplex[T][j]]);
    if (length < edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    dvecarr3E   &V,
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     dvecarr3E   &V,                                                        //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &i)                                                        //
//                                                                            //
// Return simplex minimal edge. Vertex coordinate list is provided externally //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V    : dvecarr3E, with vertex coordinate list. V[i][0], V[i][1], ... are //
//          the x, y, ... coordinates of the i-th vertex                      //
// - T    : int, simplex global index                                         //
// - edge : double, min edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int            dim = V[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm2(V[Simplex[T][1]] - V[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm2(V[Simplex[T][k]] - V[Simplex[T][j]]);
    if (length < edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the maximal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// max edge.                                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - edge      : double, maximal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
maxEdge(T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    maxEdge(I_, ddummy, j);
    if (ddummy > edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    dvecarr3E   &V,
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//     dvecarr3E   &V,                                                        //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the maximal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// max edge. Vertex list is provided externally.                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V         : dvecarr3E; vertex coordinate list. V[i][0], V[i][1], ...     //
//               are the x, y, ... coordinates of the i-th vertex             //
// - edge      : double, maximal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
maxEdge(V, T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    maxEdge(V, I_, ddummy, j);
    if (ddummy < edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &i)                                                        //
//                                                                            //
// Return simplex maximal edge.                                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T    : int, simplex global index                                         //
// - edge : double, max edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int            dim = Vertex[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm2(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm2(Vertex[Simplex[T][k]] - Vertex[Simplex[T][j]]);
    if (length > edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    dvecarr3E   &V,
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//    dvecarr3E   &V,                                                         //
//    int          T,                                                         //
//    double      &edge,                                                      //
//    int         &i)                                                         //
//                                                                            //
// Return simplex maximal edge. Vertex coordinate list is provided externally //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V    : dvecarr3E, with vertex coordinate list. V[i][0], V[i][1], ... are //
//          the x, y, ... coordinates of the i-th vertex                      //
// - T    : int, simplex global index                                         //
// - edge : double, max edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int            dim = V[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm2(V[Simplex[T][1]] - V[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm2(V[Simplex[T][k]] - V[Simplex[T][j]]);
    if (length > edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    void
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     void)                                                                  //
//                                                                            //
// Compute tasselation area.                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double          A = 0.0;

// Counters
int             T;

// ========================================================================== //
// COMPUTE TASSELATION AREA                                                   //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    A += Area(T);
} //next T

return(A); }

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    dvecarr3E   &V
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     dvecarr3E   &V)                                                        //
//                                                                            //
// Compute tasselation area. Vertex list is provided externally               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double          A = 0.0;

// Counters
int             T;

// ========================================================================== //
// COMPUTE TASSELATION AREA                                                   //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    A += Area(T, V);
} //next T

return(A); }

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    int          T
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     int T)                                                                 //
//                                                                            //
// Compute the area of a convex simplex                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T        : int, simplex index                                            //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - Area     : double, simplex area                                          //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int                    dim = Vertex[0].size();
double                 A;

// Counters
int                    i, j, m;

// ========================================================================== //
// COMPUTE THE AREA                                                           //
// ========================================================================== //
m = Simplex[T].size();
if (m == 1) {

    // Point ---------------------------------------------------------------- //
    A = 0.0;

}
else if (m == 2) {

    // Segment -------------------------------------------------------------- //
    A = norm2(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]]);

}

else if (m == 3) {

    // Triangle ------------------------------------------------------------- //
    A = 0.5 * norm2(crossProduct(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]],
                                   Vertex[Simplex[T][2]] - Vertex[Simplex[T][0]]));
}

else {

    // non-degenerate simplex ----------------------------------------------- //

    // Compute simplex-area
    A = 0.0;
    for (i = 1; i < m; i++) {
        j = (i+1) % m;
        A += 0.5 * norm2(crossProduct(
                          Vertex[Simplex[T][i]] - Vertex[Simplex[T][0]],
                          Vertex[Simplex[T][j]] - Vertex[Simplex[T][0]]));
    } //next i
}

return(A); };

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    int          T,
    dvecarr3E   &V
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     int          T,                                                        //
//     dvecarr3E   &V)                                                        //
//                                                                            //
// Compute the area of a convex simplex. Vertex list is provided externally   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T        : int, simplex index                                            //
// - V        : dvecarr3E, vertex coordinate list. X[i][0], X[i][1], ...      //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - Area     : double, triangle area                                         //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int                    dim = V[0].size();
double                 A;

// Counters
int                    i, j, m;

// ========================================================================== //
// COMPUTE THE AREA                                                           //
// ========================================================================== //
m = Simplex[T].size();

// Point -------------------------------------------------------------------- //
if (m == 1) {

    // Compute area
    A = 0.0;

}

// Segment ------------------------------------------------------------------ //
else if (m == 2) {

    // Compute area
    A = norm2(V[Simplex[T][1]] - V[Simplex[T][0]]);

}

// Triangle ----------------------------------------------------------------- //
else if (m == 3) {

    // Compute triangle's area
    A = 0.5 * norm2(crossProduct(V[Simplex[T][1]] - V[Simplex[T][0]],
                                   V[Simplex[T][2]] - V[Simplex[T][0]]));
}

// Non-degenerate simplex --------------------------------------------------- //
else {

    // Compute simplex area
    A = 0.0;
    for (i = 1; i < m; i++) {
        j = (i+1) % m;
        A += 0.5 * norm2(crossProduct(
                          V[Simplex[T][i]] - V[Simplex[T][0]],
                          V[Simplex[T][j]] - V[Simplex[T][0]]));
    } //next i
}

return(A); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::Area(
    dvector1D   &A
) {

// ========================================================================== //
// void Class_SurfTri::Area(                                                  //
//     dvector1D   &A)                                                        //
//                                                                            //
// Compute the area of each simplex in the surface tasselation                //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - A     ; dvector1D, storing the area value of each simplex                //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
A.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AREA OF EACH SIMPLEX                                               //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    A[i] = Area(i);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::Area(
    dvecarr3E   &V,
    dvector1D   &A
) {

// ========================================================================== //
// void Class_SurfTri::Area(                                                  //
//     dvecarr3E   &V,                                                        //
//     dvector1D   &A)                                                        //
//                                                                            //
// Compute the area of each simplex in a surface tasselation. Vertex          //
// coordinate list is provided externally.                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V     : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ... are     //
//           the x, y, ... coordinates of the i-th vertex.                    //
// - A     ; dvector1D, storing the area value of each simplex                //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i;


// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
A.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AREA OF EACH SIMPLEX                                               //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    A[i] = Area(i, V);
} //next i

return; }

// -------------------------------------------------------------------------- //
double Class_SurfTri::AR(
    int          T
) {

// ========================================================================== //
// double Class_SurfTri::AR(                                                  //
//     int          T)                                                        //
//                                                                            //
// Compute the aspect ratio of a given simplex in the tasselation.            //
// Aspect ratio is defined as the ratio between the longest and               //
// shortes edges in the simplex.                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T      : int, simplex index.                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int          dim = Vertex[0].size();
double       aspect = 0.0;
double       min_edge, max_edge, edge;

// Counters
int          i, j, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE AR.                                                                //
// ========================================================================== //
min_edge = max_edge = norm2(Vertex[Simplex[T][0]] - Vertex[Simplex[T][1]]);
for (i = 1; i < m; i++) {
    j = (i+1) % m;
    edge = norm2(Vertex[Simplex[T][i]] - Vertex[Simplex[T][j]]);
    min_edge = min(min_edge, edge);
    max_edge = max(max_edge, edge);
} //next i
aspect = max_edge/min_edge;

return (aspect); };

// -------------------------------------------------------------------------- //
double Class_SurfTri::AR(
    int          T,
    dvecarr3E   &V
) {

// ========================================================================== //
// double Class_SurfTri::AR(                                                  //
//     int          T,                                                        //
//     dvecarr3E   &V)                                                        //
//                                                                            //
// Compute the aspect ratio of a given simplex in the tasselation.            //
// Aspect ratio is defined as the ratio between the longest and               //
// shortes edges in the simplex.                                              //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T      : int, simplex index.                                             //
// - V        : dvecarr3E with vertex coordinate list. X[i][0], X[i][1], ...  //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
//int          dim = V[0].size();
double       aspect = 0.0;
double       min_edge, max_edge, edge;

// Counters
int          i, j, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE AR.                                                                //
// ========================================================================== //
min_edge = max_edge = norm2(V[Simplex[T][0]] - V[Simplex[T][1]]);
for (i = 1; i < m; i++) {
    j = (i+1) % m;
    edge = norm2(V[Simplex[T][i]] - V[Simplex[T][j]]);
    min_edge = min(min_edge, edge);
    max_edge = max(max_edge, edge);
} //next i
aspect = max_edge/min_edge;

return (aspect); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::AR(
    dvector1D   &aspect
) {

// ========================================================================== //
// void Class_SurfTri::AR(                                                    //
//     dvector1D   &aspect)                                                   //
//                                                                            //
// Compute the aspect ratio of each simplex in the tasselation.               //
// Aspect ratio is defined as the ratio between the longest                   //
// and shortes edges in the simplex.                                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int          i;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
aspect.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AR FOR EACH SIMPLEX IN THE TASSELATION                             //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    aspect[i] = AR(i);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::AR(
    dvecarr3E   &V,
    dvector1D   &aspect
) {

// ========================================================================== //
// void Class_SurfTri::AR(                                                    //
//     dvecarr3E   &V,                                                        //
//     dvector1D   &aspect)                                                   //
//                                                                            //
// Compute the aspect ratio of each simplex in the tasselation.               //
// Aspect ratio is defined as the ratio between the longest and               //
// shortes edges in the simplex.                                              //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V      : dvecarr3E,vertex coordinate list. V[i][0], V[i][1], ... are     //
//            the x, y, ... coordinates of the i-th vertex.                   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int          i;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
aspect.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AR FOR EACH SIMPLEX IN THE TASSELATION                             //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    aspect[i] = AR(i, V);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::Angle(
    int         T,
    double     &angle,
    int         i
) {
    
// ========================================================================== //
// void Class_SurfTri::Angle(                                                 //
//     int         T,                                                         //
//     double     &angle,                                                     //
//     int         i)                                                         //
//                                                                            //
// Compute the angle between simplex edged incident on vertex v               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T     : int, simplex global index                                        //
// - angle : double, angle value                                              //
// - i     : int, vertex local index                                          //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
darray3E        v1, v2;

// Counters
int             m = Simplex[T].size();
int             j, k;

// ========================================================================== //
// COMPUTE ANGLE'S VALUE                                                      //
// ========================================================================== //
j = (i + 1) % m;
k = (i - 1  + m) % m;
v1 = Vertex[Simplex[T][j]] - Vertex[Simplex[T][i]];
v2 = Vertex[Simplex[T][k]] - Vertex[Simplex[T][i]];
v1 = v1/norm2(v1);
v2 = v2/norm2(v2);
angle = acos(max(-1.0, min(1.0, dotProduct(v1, v2))));

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::Angle(
    dvecarr3E  &V,
    int         T,
    double     &angle,
    int         i
) {
    
// ========================================================================== //
// void Class_SurfTri::Angle(                                                 //
//     dvecarr3E  &V,                                                         //
//     int         T,                                                         //
//     double     &angle,                                                     //
//     int         i)                                                         //
//                                                                            //
// Compute the angle between simplex edged incident on vertex v. Vertex       //
// coordinate list is provided externally.                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V     : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ... are the //
//           x, y, ... coordinates of the i-th vertex.                        //
// - T     : int, simplex global index                                        //
// - angle : double, angle value                                              //
// - i     : int, vertex local index                                          //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
darray3E        v1, v2;

// Counters
int             m = Simplex[T].size();
int             j, k;

// ========================================================================== //
// COMPUTE ANGLE'S VALUE                                                      //
// ========================================================================== //
j = (i + 1) % m;
k = (i - 1  + m) % m;
v1 = V[Simplex[T][j]] - V[Simplex[T][i]];
v2 = V[Simplex[T][k]] - V[Simplex[T][i]];
v1 = v1/norm2(v1);
v2 = v2/norm2(v2);
angle = acos(max(-1.0, min(1.0, dotProduct(v1, v2))));

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     double      &angle,                                                    //
//     int         &T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the min angle over all simplicies in the tasselation, and returns  //
// the global index of simplex and the local index of vertex at min angle.    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - angle   : double, min angle value                                        //
// - T       : int, simplex global index                                      //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      value;

// Counters
int         I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
minAngle(T, angle, v);
for (I_ = 1; I_ < nSimplex; T++) {
    minAngle(I_, value, i);
    if (value < angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next T

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvecarr3E   &V,
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     dvecarr3E   &V,                                                        //
//     double      &angle,                                                    //
//     int         &T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the min angle over all simplicies in the tasselation, and returns  //
// the global index of simplex and the local index of vertex at min angle.    //
// Vertex list is provided externally.                                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V       : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ...are    //
//             the x, y, ... coordinates of the i-th vertex                   //
// - angle   : double, min angle value                                        //
// - T       : int, simplex global index                                      //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      value;

// Counters
int         I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
minAngle(T, angle, v);
for (I_ = 1; I_ < nSimplex; T++) {
    minAngle(V, I_, value, i);
    if (value < angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next T

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     int          T,                                                        //
//     double      &angle,                                                    //
//     int         &v)                                                        //
//                                                                            //
// Compute the min angle between two subsequent edges of a given simplex      //
// and returns the min angle.                                                 //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      value;

// Counters
int         i;
int         m = Simplex[T].size();

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = pi;
for (i = 0; i < m; i++) {
    Angle(T, value, i);
    if (value < angle) {
        angle = value;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvecarr3E   &V,
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// double Class_SurfTri::minAngle(                                            //
//     int T,                                                                 //
//     dvecarr3E &V)                                                          //
//                                                                            //
// Compute the min angle between two subsequent edges of a given simplex, and //
// returns the min value. Vertex coordinate list is provided externally.      //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V      : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ... are    //
//            the x, y, ... coordinates of the i-th vertex.                   //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      value;

// Counters
int         i;
int         m = Simplex[T].size();

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = pi;
for (i = 0; i < m; i++) {
    Angle(T, value, i);
    if (value < angle) {
        angle = value;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvector1D  &angle
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     dvector1D  &angle)                                                     //
//                                                                            //
// Compute the min angle of each simplex in a surface tasselation             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - angle ; dvector1D, storing the min angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    minAngle(i, angle[i], j);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvecarr3E   &V,
    dvector1D  &angle
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     dvecarr3E   &V,                                                        //
//     dvector1D  &angle)                                                     //
//                                                                            //
// Compute the min angle for each simplex in the surface tasselation.         //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V     : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ... are     //
//           the x, y, ... coordinates of the i-th vertex.                    //
// - angle : dvector1D, storing the min angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    minAngle(V, i, angle[i], j);
} //next i

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     double      &edge,                                                     //
//     int          T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle over all simplicies in the tassalation,              //
// and returns the global index of simplex and the local index of vertex      //
// at max angle.                                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double    value;

// Counters
int       I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
maxAngle(T, angle, v);
for (I_ = 1; I_ < nSimplex; I_++) {
    maxAngle(I_, value, i);
    if (value > angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next i


return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvecarr3E   &V,
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvecarr3E   &V,                                                        //
//     double      &edge,                                                     //
//     int          T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle over all simplicies in the tassalation,              //
// and returns the global index of simplex and the local index of vertex      //
// at max angle. Vertex list is provided externally.                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V       : dvector1D, vertex coordinate list. V[i][0], V[i][1], ... are   //
//             the x, y, ... coordinates of the i-th vertex.                  //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double    value;

// Counters
int       I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
maxAngle(V, T, angle, v);
for (I_ = 1; I_ < nSimplex; I_++) {
    maxAngle(V, I_, value, i);
    if (value > angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle between two subsequent edges of a given simplex,     //
// and returns the local index of vertex at max angle.                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double    value;

// Counters
int       m = Simplex[T].size();
int       i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = 0.0;
for (i = 0; i < m; i++) {
    Angle(T, value, i);
    if (value > angle) {
        angle = value;
        v = i;
    }
} //next i


return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvecarr3E   &V,
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvecarr3E   &V,                                                        //
//     int          T,                                                        //
//     double      &angle,                                                    //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle between two subsequent edges of a given simplex,     //
// and returns the local index of vertex at max angle.                        //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V      : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ... are    //
//            x, y, ... coordinates of the i-th vertex.                       //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double    value;

// Counters
int       i;
int       m = Simplex[T].size();

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = 0.0;
for (i = 0; i < m; i++) {
    Angle(V, T, value, i);
    if (value > angle) {
        angle = value;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvector1D   &angle
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvector1D   &angle)                                                    //
//                                                                            //
// Compute the max angle of each simplex in the surface tasselation           //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - angle ; dvector1D, storing the max angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    maxAngle(i, angle[i], j);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvecarr3E   &V,
    dvector1D   &angle
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvecarr3E   &V,                                                        //
//     dvector1D   &angle)                                                    //
//                                                                            //
// Compute the max angle in each simplex in a surface tasselation.            //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V     : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ... are     //
//           the x, y, ... coordinates of the i-th vertex.                    //
// - angle ; dvector1D, storing the max angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    maxAngle(V, i, angle[i], j);
} //next i

return; }

// -------------------------------------------------------------------------- //
darray3E  Class_SurfTri::Edge_midPoint(
    int          T,
    int          e
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Edge_midPoint(                                    //
//     int          T,                                                        //
//     int          e)                                                        //
//                                                                            //
// Compute midpoint of simplex edge.                                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - e       : int, edge local index                                          //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P       : dvector1D, with midpoint coordinates                           //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                    n ;
darray3E               P;

// Counters
int                    j, k;

// ========================================================================== //
// COMPUTE MID POINT FOR A GIVEN EDGE.                                        //
// ========================================================================== //

// Simplex type
n = Simplex[T].size();

// Point
if (n == 1){
    P = Vertex[Simplex[T][e]];
}

// Segment
else if (n == 2) {
    P = Vertex[Simplex[T][e]];
}

// Simplex
else {
    k = (e + 1) % n;
    P = 0.5*(Vertex[Simplex[T][e]] + Vertex[Simplex[T][k]]);
}

return(P); };

// -------------------------------------------------------------------------- //
darray3E  Class_SurfTri::Edge_midPoint(
    dvecarr3E   &V,
    int          T,
    int          e
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Edge_midPoint(                                    //
//     dvecarr3E   &V,                                                        //
//     int          T,                                                        //
//     int          e)                                                        //
//                                                                            //
// Compute mid point of a simplex edge. Vertex list is provided externally    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, Simplex global index                                      //
// - e       : int, edge local index                                          //
// - V       : dvecarr3E, vertex coordinate list. V[i][0], V[i][1], ... are   //
//             the x, y, ... coordinates of the i-th vertex.                  //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P       : dvector1D, with mid point coordinates                          //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                    n;
darray3E               P;

// Counters
int                    j, k;

// ========================================================================== //
// COMPUTE MID POINT FOR A GIVEN EDGE.                                        //
// ========================================================================== //

// Simplex type
n = Simplex[T].size();

// Point
if (n == 1) {
    P = V[Simplex[T][e]];
}

// Segment
else if (n == 2) {
    P = V[Simplex[T][e]];
}

// Simplex
else {
    k = (e + 1) % n;
    P = 0.5*(V[Simplex[T][e]] + V[Simplex[T][k]]);
}

return(P); };

// ----------------------------------------------------------------------------------- //
darray3E  Class_SurfTri::CircumCenter(
    int T
) {

// =================================================================================== //
// dvector1D Class_SurfTri::CircumCenter(                                              //
//     int T)                                                                          //
//                                                                                     //
// Compute simplex circum center. (2-simplicies only).                                 //
// =================================================================================== //
// INPUT                                                                               //
// =================================================================================== //
// - T        : int, simplex global index                                              //
// =================================================================================== //
// OUTPUT                                                                              //
// =================================================================================== //
// - P        : dvector1D, with circum center coordinates                              //
// =================================================================================== //

// =================================================================================== //
// VARIABLES DECLARATION                                                               //
// =================================================================================== //

// Local variables
darray3E            P;
darray3E            Q, n, M1, n1, M2, n2;

// Counters
int                 i;

// =================================================================================== //
// COMPUTE CIRCUMCENTER                                                                //
// =================================================================================== //

// Compute triangle normal ----------------------------------------------------------- //

// Compute bisect. for edge 0. ------------------------------------------------------- //

    // Edge slope
    n1 = Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]];
    n1 = n1/norm2(n1);

    // Edge mid point
    M1 = Edge_midPoint(T, 0);

// Compute bisect. for edge 1. ------------------------------------------------------- //

    // Edge slope
    n2 = Vertex[Simplex[T][2]] - Vertex[Simplex[T][1]];
    n2 = n2/norm2(n2);

    // Edge mid point
    M2 = Edge_midPoint(T, 1);

// Circumcenter coordinates ---------------------------------------------------------- //

    // Triangle's normal
    n = crossProduct(n1, n2);
    n = n/norm2(n);

    // Bisect directions
    n1 = crossProduct(n, n1);
    n2 = crossProduct(n, n2);

    // Intersection point
    P = IntersectLines(n1,M1,n2,M2);

return(P); };

// ----------------------------------------------------------------------------------- //
darray3E  Class_SurfTri::CircumCenter(
    int T,
    dvecarr3E &V
) {

// =================================================================================== //
// dvector1D Class_SurfTri::CircumCenter(                                              //
//     int T,                                                                          //
//     dvecarr3E &V)                                                                   //
//                                                                                     //
// Compute simplex circum center. (2-simplicies only). Vertex coordnate list is        //
// provided externally.                                                                //
// =================================================================================== //
// INPUT                                                                               //
// =================================================================================== //
// - T        : int, simplex global index                                              //
// - V        : dvecarr3E, with vertex coordinate list. V[i][0], V[i][1], ... are the  //
//             x, y, ... coordinates of the i-th vertex.                               //
// =================================================================================== //
// OUTPUT                                                                              //
// =================================================================================== //
// - P        : dvector1D, with circum center coordinates                              //
// =================================================================================== //

// =================================================================================== //
// VARIABLES DECLARATION                                                               //
// =================================================================================== //

// Local variables
darray3E            P;
darray3E            Q, n, M1, n1, M2, n2;

// Counters
int                 i;

// =================================================================================== //
// COMPUTE CIRCUMCENTER                                                                //
// =================================================================================== //

// Compute bisect. for edge 0. ------------------------------------------------------- //

    // Slope
    n1 = V[Simplex[T][1]] - V[Simplex[T][0]];
    n1 = n1/norm2(n1);

    // Point
    M1 = Edge_midPoint(V, T, 0);

// Compute bisect. for edge 1. ------------------------------------------------------- //

    // Slope
    n2 = V[Simplex[T][2]] - V[Simplex[T][1]];
    n2 = n2/norm2(n2);

    // Point
    M2 = Edge_midPoint(V, T, 1);

// Circumcenter coordinates ---------------------------------------------------------- //

    // Triangle's normal
    n = crossProduct(n1, n2);
    n = n/norm2(n);

    // Bisect directions
    n1 = crossProduct(n, n1);
    n2 = crossProduct(n, n2);

    // Intersection point
    P = IntersectLines(n1,M1,n2,M2);

return(P); };

// -------------------------------------------------------------------------- //
int Class_SurfTri::VertexValence(
    int          T,
    int          i
) {

// ========================================================================== //
// int Class_SurfTri::VertexValence(                                          //
//     int          T,                                                        //
//     int          i)                                                        //
//                                                                            //
// Compute valence of a given vertex.                                         //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, global index of simplex which vertex belongs to           //
// - i       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - val     : int, vertex valence                                            //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bool       flag = true;
int        val;
ivector1D  ring1;

// Counters
// none

// ========================================================================== //
// COMPUTE VERTEX VALENCE                                                     //
// ========================================================================== //

// Compute the 1 ring of vertex
ring1 = Ring_1(T, i, flag);

// Valence - closed ring
if (flag) {
    val = ring1.size();
}
// Valence - open ring
else {
    val = ring1.size() + 1;
}

return (val); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::VertexValence(
    ivector1D   &Val
) {

// ========================================================================== //
// void Class_SurfTri::VertexValence(                                         //
//     ivector1D &Val)                                                        //
//                                                                            //
// Compute valence for each vertex in the tasselation                         //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - Val    : ivector1D, with valence score for each vertex                   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int      V, T, i, m;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
Val.resize(nVertex, 0);

// ========================================================================== //
// COMPUTE VERTEX VALENCE                                                     //
// ========================================================================== //

// Reset valence value ------------------------------------------------------ //
for (i = 0; i < nVertex; i++) {
    Val[i] = 0;
} //next i

// Compute valence score ---------------------------------------------------- //
for (T = 0; T < nSimplex; T++) {
    m = Simplex[T].size();
    for (i = 0; i < m; i++) {
        V = Simplex[T][i];
        if (Val[V] == 0) {
            Val[V] = VertexValence(T, i);
        }
    } //next i
} //next T

return; };


// -------------------------------------------------------------------------- //
bool Class_SurfTri::PointsOnSameSide(
        array< double, 3 > const &P1,
        array< double, 3 > const &P2,
        array< double, 3 > const &A,
        array< double, 3 > const &B
        ) {

    // ========================================================================== //
    // bool SameSide(                                                             //
    //     array< double, 3 > const &P1,                                          //
    //     array< double, 3 > const &P2,                                          //
    //     array< double, 3 > const &A,                                           //
    //     array< double, 3 > const &B)                                           //
    //                                                                            //
    // Check if point P1 and P2 lie on the same side of segment (A,B)             //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - P1     : array<double, 3> 1st argument of check                          //
    // - P2     : array<double, 3> 2nd argument of check                          //
    // - A      : array<double, 3> 1st vertex of the segment                      //
    // - B      : array<double, 3> 2nd vertex of the segment                      //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - flag   : bool, check result. if flag = true, then P1, and P2 lie on the  //
    //            same side of the segment (A, B). Otherwise flag = false.        //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    bool                flag;
    double              s;
    array< double, 3 >  cp1, cp2;

    // Counters
    // none

    // ========================================================================== //
    // PERFORM CHECK                                                              //
    // ========================================================================== //
    cp1 = crossProduct(P1 - A, B - A);
    cp1 = cp1/norm(cp1, 2);
    cp2 = crossProduct(P2 - A, B - A);
    cp2 = cp2/norm(cp2, 2);
    s = dotProduct(cp1, cp2);
    flag = (s >= 0.0);

    return(flag); };

// -------------------------------------------------------------------------- //
array<double, 3> Class_SurfTri::IntersectLines(
        array<double, 3> const &n1,
        array<double, 3> const &P1,
        array<double, 3> const &n2,
        array<double, 3> const &P2
        ) {

    // ========================================================================== //
    // array<double, 3> IntersectLines(                                           //
    //     array<double, 3> const &n1,                                            //
    //     array<double, 3> const &P1,                                            //
    //     array<double, 3> const &n2,                                            //
    //     array<double, 3> const &P2)                                            //
    //                                                                            //
    // Compute the intersection point between two line in a 3D Euclidean space.   //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - n1      : array<double, 3>, unit vector along 1st line direction         //
    // - P1      : array<double, 3>, point which 1st line passes through          //
    // - n2      : array<double, 3>, unit vector along 2nd line direction         //
    // - P2      : array<double, 3>, point which 2nd line passes through          //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - P       : array<double, 3>, intersection point                           //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    double                  xi, delta, den;
    array<double, 3>        P;

    // Counters
    // none

    // ========================================================================== //
    // COMPUTE INTERSECTION POINT.                                                //
    // ========================================================================== //
    delta = dotProduct(n1, n2);
    if (abs((abs(delta) - 1.0)) < 1.0e-12) {
        P[0] = P[1] = P[2] = 1.0e+12;
    }
    else {
        den = (1.0 - pow(delta, 2));
        xi = (dotProduct(P2, n1)
                - dotProduct(P1, n1)
                + delta * (dotProduct(P1, n2) - dotProduct(P2, n2))) / den;
        P = P1 + xi * n1;
    }

    return(P); };

